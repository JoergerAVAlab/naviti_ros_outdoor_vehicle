// Generated by gencpp from file novatel_pkg/BESTPOS.msg
// DO NOT EDIT!


#ifndef NOVATEL_PKG_MESSAGE_BESTPOS_H
#define NOVATEL_PKG_MESSAGE_BESTPOS_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <novatel_pkg/CommonLongHeader.h>

namespace novatel_pkg
{
template <class ContainerAllocator>
struct BESTPOS_
{
  typedef BESTPOS_<ContainerAllocator> Type;

  BESTPOS_()
    : header()
    , sol_stat(0)
    , pos_type(0)
    , lat(0.0)
    , lon(0.0)
    , hgt(0.0)
    , undulation(0.0)
    , datum_id(0)
    , lat_std(0.0)
    , long_std(0.0)
    , hgt_std(0.0)
    , stn_id()
    , diff_age(0.0)
    , sol_age(0.0)
    , num_sats(0)
    , num_sol_sats(0)
    , num_sol_l1_sats(0)
    , num_sol_multi_sats(0)  {
    }
  BESTPOS_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , sol_stat(0)
    , pos_type(0)
    , lat(0.0)
    , lon(0.0)
    , hgt(0.0)
    , undulation(0.0)
    , datum_id(0)
    , lat_std(0.0)
    , long_std(0.0)
    , hgt_std(0.0)
    , stn_id(_alloc)
    , diff_age(0.0)
    , sol_age(0.0)
    , num_sats(0)
    , num_sol_sats(0)
    , num_sol_l1_sats(0)
    , num_sol_multi_sats(0)  {
  (void)_alloc;
    }



   typedef  ::novatel_pkg::CommonLongHeader_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef uint32_t _sol_stat_type;
  _sol_stat_type sol_stat;

   typedef uint32_t _pos_type_type;
  _pos_type_type pos_type;

   typedef double _lat_type;
  _lat_type lat;

   typedef double _lon_type;
  _lon_type lon;

   typedef double _hgt_type;
  _hgt_type hgt;

   typedef float _undulation_type;
  _undulation_type undulation;

   typedef uint32_t _datum_id_type;
  _datum_id_type datum_id;

   typedef float _lat_std_type;
  _lat_std_type lat_std;

   typedef float _long_std_type;
  _long_std_type long_std;

   typedef float _hgt_std_type;
  _hgt_std_type hgt_std;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _stn_id_type;
  _stn_id_type stn_id;

   typedef float _diff_age_type;
  _diff_age_type diff_age;

   typedef float _sol_age_type;
  _sol_age_type sol_age;

   typedef uint8_t _num_sats_type;
  _num_sats_type num_sats;

   typedef uint8_t _num_sol_sats_type;
  _num_sol_sats_type num_sol_sats;

   typedef uint8_t _num_sol_l1_sats_type;
  _num_sol_l1_sats_type num_sol_l1_sats;

   typedef uint8_t _num_sol_multi_sats_type;
  _num_sol_multi_sats_type num_sol_multi_sats;





  typedef boost::shared_ptr< ::novatel_pkg::BESTPOS_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::novatel_pkg::BESTPOS_<ContainerAllocator> const> ConstPtr;

}; // struct BESTPOS_

typedef ::novatel_pkg::BESTPOS_<std::allocator<void> > BESTPOS;

typedef boost::shared_ptr< ::novatel_pkg::BESTPOS > BESTPOSPtr;
typedef boost::shared_ptr< ::novatel_pkg::BESTPOS const> BESTPOSConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::novatel_pkg::BESTPOS_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::novatel_pkg::BESTPOS_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::novatel_pkg::BESTPOS_<ContainerAllocator1> & lhs, const ::novatel_pkg::BESTPOS_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.sol_stat == rhs.sol_stat &&
    lhs.pos_type == rhs.pos_type &&
    lhs.lat == rhs.lat &&
    lhs.lon == rhs.lon &&
    lhs.hgt == rhs.hgt &&
    lhs.undulation == rhs.undulation &&
    lhs.datum_id == rhs.datum_id &&
    lhs.lat_std == rhs.lat_std &&
    lhs.long_std == rhs.long_std &&
    lhs.hgt_std == rhs.hgt_std &&
    lhs.stn_id == rhs.stn_id &&
    lhs.diff_age == rhs.diff_age &&
    lhs.sol_age == rhs.sol_age &&
    lhs.num_sats == rhs.num_sats &&
    lhs.num_sol_sats == rhs.num_sol_sats &&
    lhs.num_sol_l1_sats == rhs.num_sol_l1_sats &&
    lhs.num_sol_multi_sats == rhs.num_sol_multi_sats;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::novatel_pkg::BESTPOS_<ContainerAllocator1> & lhs, const ::novatel_pkg::BESTPOS_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace novatel_pkg

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::novatel_pkg::BESTPOS_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::novatel_pkg::BESTPOS_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::novatel_pkg::BESTPOS_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::novatel_pkg::BESTPOS_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::novatel_pkg::BESTPOS_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::novatel_pkg::BESTPOS_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::novatel_pkg::BESTPOS_<ContainerAllocator> >
{
  static const char* value()
  {
    return "9f8dc9710a4cb96033fd5b5ef2cdb331";
  }

  static const char* value(const ::novatel_pkg::BESTPOS_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x9f8dc9710a4cb960ULL;
  static const uint64_t static_value2 = 0x33fd5b5ef2cdb331ULL;
};

template<class ContainerAllocator>
struct DataType< ::novatel_pkg::BESTPOS_<ContainerAllocator> >
{
  static const char* value()
  {
    return "novatel_pkg/BESTPOS";
  }

  static const char* value(const ::novatel_pkg::BESTPOS_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::novatel_pkg::BESTPOS_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# INSPVAS Message ID: 508\n"
"# Author: Brandon Medellin\n"
"# Date: 2/10/2023\n"
"\n"
"novatel_pkg/CommonLongHeader header\n"
"\n"
"# Solution Status \n"
"uint32 sol_stat\n"
"\n"
"# Position type\n"
"uint32 pos_type\n"
"\n"
"# Latitude \n"
"float64 lat\n"
"\n"
"# Longitude\n"
"float64 lon\n"
"\n"
"# Height above mean sea level (metres)\n"
"float64 hgt\n"
"\n"
"# undulation\n"
"float32 undulation\n"
"\n"
"# Datum ID Number \n"
"uint32 datum_id\n"
"\n"
"# Latitude statdard dev\n"
"float32 lat_std\n"
"\n"
"# Longitude standard dev\n"
"float32 long_std\n"
"\n"
"# Height standard dev \n"
"float32 hgt_std\n"
"\n"
"# Base station ID \n"
"string stn_id\n"
"\n"
"# Differential age in seconds\n"
"float32 diff_age\n"
"\n"
"# Solution age in seconds\n"
"float32 sol_age\n"
"\n"
"# Number of Satellites tracked \n"
"uint8 num_sats\n"
"\n"
"# Number of satellites used in solution \n"
"uint8 num_sol_sats\n"
"\n"
"# Number of satellites  with L1/E1/B1 signals used in solution\n"
"uint8 num_sol_l1_sats\n"
"\n"
"# Number of satellites with multi-frequency signals used in solution\n"
"uint8 num_sol_multi_sats\n"
"\n"
"# Reserved\n"
"\n"
"\n"
"# ext sol stat \n"
"\n"
"\n"
"# Galileo and BeiDou sig mask \n"
"\n"
"\n"
"# GPS and GLONASS sig mask\n"
"\n"
"================================================================================\n"
"MSG: novatel_pkg/CommonLongHeader\n"
"# Long Binary Header NovAtel\n"
"# Author: Brandon Medellin\n"
"# Date: 2/1/2023\n"
"\n"
"# Length of the header\n"
"uint8 head_length\n"
"\n"
"# Message ID of the log being output\n"
"uint16 id\n"
"\n"
"# Measurement source, format, response bit.\n"
"uint8 msg_type\n"
"\n"
"# Port address\n"
"uint8 port_addr\n"
"\n"
"# Message length not including header (25 bytes) nor CRC (4 bytes)\n"
"uint16 length\n"
"\n"
"# Used for multiple related logs. It is a number that counts down from N-1 to 0 where N is the number of related logs ...\n"
"uint16 sequence\n"
"\n"
"# Time the processor is idle, calculated once per second - more in documentation\n"
"uint8 idle_time\n"
"\n"
"# Indicates the quality of the gps reference time\n"
"uint8 time_status\n"
"\n"
"# GNSS week number\n"
"uint16 gnss_week\n"
"\n"
"# GNSS Miliseconds from beginning of GNSS week\n"
"int32 gnss_mili\n"
"\n"
"# Reserved for internal use\n"
"uint16 reserved\n"
"\n"
"# A value (0-65535) representing the receiver software build number\n"
"uint16 software_version\n"
"\n"
;
  }

  static const char* value(const ::novatel_pkg::BESTPOS_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::novatel_pkg::BESTPOS_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.sol_stat);
      stream.next(m.pos_type);
      stream.next(m.lat);
      stream.next(m.lon);
      stream.next(m.hgt);
      stream.next(m.undulation);
      stream.next(m.datum_id);
      stream.next(m.lat_std);
      stream.next(m.long_std);
      stream.next(m.hgt_std);
      stream.next(m.stn_id);
      stream.next(m.diff_age);
      stream.next(m.sol_age);
      stream.next(m.num_sats);
      stream.next(m.num_sol_sats);
      stream.next(m.num_sol_l1_sats);
      stream.next(m.num_sol_multi_sats);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct BESTPOS_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::novatel_pkg::BESTPOS_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::novatel_pkg::BESTPOS_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::novatel_pkg::CommonLongHeader_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "sol_stat: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.sol_stat);
    s << indent << "pos_type: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.pos_type);
    s << indent << "lat: ";
    Printer<double>::stream(s, indent + "  ", v.lat);
    s << indent << "lon: ";
    Printer<double>::stream(s, indent + "  ", v.lon);
    s << indent << "hgt: ";
    Printer<double>::stream(s, indent + "  ", v.hgt);
    s << indent << "undulation: ";
    Printer<float>::stream(s, indent + "  ", v.undulation);
    s << indent << "datum_id: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.datum_id);
    s << indent << "lat_std: ";
    Printer<float>::stream(s, indent + "  ", v.lat_std);
    s << indent << "long_std: ";
    Printer<float>::stream(s, indent + "  ", v.long_std);
    s << indent << "hgt_std: ";
    Printer<float>::stream(s, indent + "  ", v.hgt_std);
    s << indent << "stn_id: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.stn_id);
    s << indent << "diff_age: ";
    Printer<float>::stream(s, indent + "  ", v.diff_age);
    s << indent << "sol_age: ";
    Printer<float>::stream(s, indent + "  ", v.sol_age);
    s << indent << "num_sats: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.num_sats);
    s << indent << "num_sol_sats: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.num_sol_sats);
    s << indent << "num_sol_l1_sats: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.num_sol_l1_sats);
    s << indent << "num_sol_multi_sats: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.num_sol_multi_sats);
  }
};

} // namespace message_operations
} // namespace ros

#endif // NOVATEL_PKG_MESSAGE_BESTPOS_H
